# Файл `useCardManager.ts` - Документация

## Назначение
Этот пользовательский хук (`useCardManager`) управляет интерактивными карточками, реализуя:
- Шахматное расположение карточек
- Анимацию выбора карточки
- Затемнение фона при активации
- Автоматический сброс состояния

## Основные методы и функции

### `useEffect` для инициализации
```typescript
useEffect(() => {
  bodyRef.current = document.body as HTMLBodyElement;
  return () => {
    resetActiveCards();
  };
}, []);
Назначение:
Инициализирует ссылки и выполняет очистку при размонтировании компонента.

Принцип работы:

При монтировании сохраняет ссылку на <body>

При размонтировании сбрасывает активные карточки

calculateOffsets()
typescript
const calculateOffsets = () => {
  // ... реализация
};
Назначение:
Вычисляет шахматное расположение карточек.

Алгоритм:

Определяет количество карточек в строке

Для нечетных строк пропускает последнюю карточку

Смещает каждую вторую карточку на 50% вниз

Оптимизация:

Вызывается с debounce при ресайзе окна

handleCardClick()
typescript
const handleCardClick = (cardRef: React.RefObject<HTMLDivElement>) => {
  // ... реализация
};
Назначение:
Обрабатывает клик по карточке, запуская анимацию.

Последовательность действий:

Проверяет возможность активации

Создает плейсхолдер

Запускает анимацию

Через 3 секунды автоматически сбрасывает состояние

activateCard() / deactivateCard()
typescript
const activateCard = (card: HTMLDivElement) => {
  // ... реализация
};

const deactivateCard = (card: HTMLDivElement) => {
  // ... реализация
};
Назначение:
Управляют состоянием активной карточки.

Функционал:

Блокировка скролла страницы

Добавление/удаление CSS-классов

Показ/скрытие метки выбора

createPlaceholder() / removePlaceholder()
typescript
const createPlaceholder = (card: HTMLDivElement) => {
  // ... реализация
};

const removePlaceholder = () => {
  // ... реализация
};
Назначение:
Сохраняют место в DOM при анимации.

Особенности:

Точное соответствие размерам карточки

Невидим для пользователя

Предотвращает "прыжки" верстки

setCardPosition()
typescript
const setCardPosition = (card: HTMLDivElement) => {
  // ... реализация
};
Назначение:
Подготавливает CSS-переменные для анимации.

Устанавливает:

--card-top - вертикальная позиция

--card-left - горизонтальная позиция

--card-scale - масштаб

Возвращаемые значения
Хук возвращает объект с методами:

typescript
return {
  handleCardClick, // Функция обработки клика
  overlayRef,      // Ref для элемента затемнения
};
Принципы работы
Анимация реализована через CSS, управляется через классы

Оптимизация:

Debounce для обработки ресайза

Минимальное количество перерисовок

Безопасность:

Проверки существования элементов

Очистка эффектов

Использование
typescript
const { handleCardClick, overlayRef } = useCardManager({ cardsContainerRef });









/**
 * useEffect для инициализации и очистки
 * 
 * useEffect - это хук React, который выполняет побочные эффекты в функциональных компонентах.
 * В данном случае:
 * 1. При монтировании компонента (первом рендере) сохраняем ссылку на body документа
 * 2. Возвращаем функцию очистки, которая выполнится при размонтировании компонента
 *    для сброса состояния активных карточек
 * 
 * Пустой массив зависимостей [] означает, что эффект выполнится только один раз
 */
useEffect(() => {
  bodyRef.current = document.body as HTMLBodyElement;
  return () => {
    resetActiveCards();
  };
}, []);

/**
 * Обработчик клика handleCardClick - управляет анимацией карточки
 * 
 * Последовательность действий:
 * 1. Проверяем доступность карточки и отсутствие других активных карточек
 * 2. Сбрасываем предыдущие активные карточки
 * 3. Создаем невидимый плейсхолдер на месте карточки (чтобы не ломалась верстка)
 * 4. Запоминаем текущую позицию карточки (для анимации)
 * 5. Активируем карточку (добавляем класс, блокируем скролл)
 * 6. Показываем оверлей (затемнение фона)
 * 7. Через 3 секунды автоматически сбрасываем состояние
 */
const handleCardClick = (cardRef: React.RefObject<HTMLDivElement>) => {
  // ... реализация
};

/**
 * Эффект для обработки ресайза окна
 * 
 * Особенности:
 * - Использует debounce для оптимизации (вызов не чаще чем раз в 100мс)
 * - При изменении размеров окна пересчитывает позиции карточек
 * - Автоматически отписывается от события при размонтировании компонента
 * 
 * Debounce нужен чтобы избежать:
 * 1. Чрезмерного количества вызовов при ресайзе
 * 2. Проблем с производительностью
 * 3. "Дребезга" интерфейса
 */
useEffect(() => {
  const handleResize = debounce(() => {
    calculateOffsets();
  }, 100);

  window.addEventListener('resize', handleResize);
  return () => {
    window.removeEventListener('resize', handleResize);
  };
}, []);

/**
 * Функция createPlaceholder - создание плейсхолдера
 * 
 * Зачем нужен:
 * - Сохраняет место в DOM при анимации карточки
 * - Предотвращает "прыжки" других карточек
 * 
 * Как работает:
 * 1. Получает текущие размеры и позицию карточки
 * 2. Создает невидимый div с такими же размерами
 * 3. Вставляет его перед карточкой в DOM
 * 4. При сбросе анимации - удаляет плейсхолдер
 */
const createPlaceholder = (card: HTMLDivElement) => {
  // ... реализация
};

/**
 * Функция setCardPosition - подготовка к анимации
 * 
 * Что делает:
 * 1. Получает текущую позицию карточки относительно viewport
 * 2. Учитывает текущий скролл страницы
 * 3. Сохраняет позицию в CSS переменных:
 *    --card-top / --card-left - для позиционирования
 *    --card-scale - для масштабирования
 * 
 * Эти переменные используются в CSS-анимации компонента Card
 */
const setCardPosition = (card: HTMLDivElement) => {
  // ... реализация
};














На всякий случай шахматный порядок сохранил:

  const calculateOffsets = () => {
    const cardsContainer = cardsContainerRef.current;
    if (!cardsContainer) return;

    const cards = cardsContainer.querySelectorAll('.card');
    if (cards.length === 0) return;

    // Жёстко заданные параметры
    const cardsPerRow = 9;
    const offsetY = 50; // Фиксированное смещение в пикселях

    cards.forEach((card, index) => {
      const positionInRow = index % cardsPerRow;

      // смещение нечётных позиций
      const shouldOffset = positionInRow % 2 === 1;

      if (shouldOffset) {
        (card as HTMLElement).style.transform = `translateY(${offsetY}px)`;
      } else {
        (card as HTMLElement).style.transform = 'translateY(0)';
      }
    });
  };